---
title: "Introduction to dplyr"
author: "Reiko Okamoto"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## üëãWelcome to the tidyverse

#### ***What is the tidyverse?***

The [tidyverse](https://tidyverse.tidyverse.org/) is a collection of R packages designed for data science. Arguably, two of the most popular packages in the tidyverse are [dplyr](https://dplyr.tidyverse.org/) for data manipulation and [ggplot2](https://ggplot2.tidyverse.org/) for data visualization. These are also the packages that we are covering today!

***Why learn it?***

The skills you gain are not just limited to R. The concepts, like filtering data and creating plots, are applicable to other languages like SQL and Python. This makes it easier to pick up other tools and languages later. Additionally, the tidyverse is in tune with open science practices, helping you create analyses that are more accessible, transparent, and reproducible.

***Keep in mind...***

There's no expectation for you to memorize everything. Even experienced programmers don't have every function memorized - they're constantly googling things! My goal today is to help you get comfortable with, and hopefully interested in, using the tidyverse for data analysis.

## üêßMeet the Palmer penguins

![](imgs/penguins.png){width="500"}

We'll use the **penguins** data set from the [palmerpenguins](https://allisonhorst.github.io/palmerpenguins/) package. It contains measurements for adult penguins observed in the islands in the Palmer Archipelago off the Antarctic Peninsula. The data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. This data set is great for learning because it's small enough to be manageable for beginners but contains a range of different types of data and features.

üíªLoad the necessary packages:

```{r}
library(tidyverse)
library(palmerpenguins)
```

üíªOpen the data set documentation:

```{r}
?penguins
```

![](imgs/culmen_depth.png){width="500"}

## 1Ô∏è‚É£Get a glimpse of your data: glimpse()

üíªInspect the data using the [glimpse()](https://dplyr.tidyverse.org/reference/glimpse.html) function.

```{r}
glimpse(penguins)
```

-   *How many rows?*

-   *How many columns?*

-   *How many data types?*

-   *Are there any missing values?*

## 2Ô∏è‚É£Keep or drop columns: select()

Sometimes, you only need to work with a few specific columns instead of the entire data. The [select()](https://dplyr.tidyverse.org/reference/select.html) function makes it easy to do just that. It allows you to focus on the columns you need and ignore the rest, making your code cleaner.

üíªSelect one column by name:

```{r}
select(penguins, species)
```

üíªSelect two columns by name:

```{r}
select(penguins, species, island)
select(penguins, c(species, island))
```

üíªSelect all columns except certain ones:

```{r}
select(penguins, -species, -island)
```

üíªSelect columns that start with "bill":

```{r}
select(penguins, starts_with("bill"))
```

Similar functions like ends_with() and contains() are also available to select columns based on the ending or presence of specific characters.

üíªSelect numeric variables:

```{r}
select(penguins, where(is.numeric))
```

## 3Ô∏è‚É£Keep rows that match a condition: filter()

Filtering data is a common task in data analysis. Use the [filter()](https://dplyr.tidyverse.org/reference/filter.html) function to focus on specific observations.

üíªShow only the penguins of the Gentoo species:

```{r}
filter(penguins, species == "Gentoo")
```

üíªFind all Adelie penguins that are also on Torgersen Island:

```{r}
filter(penguins, species == "Adelie", island == "Torgersen")
```

The comma acts as an AND operator, meaning both conditions must be true for a row to be included.

üíªFind all penguins that either Adelie or Gentoo:

```{r}
filter(penguins, species == "Adelie" | species == "Gentoo")
filter(penguins, species != "Chinstrap")
```

The vertical bar acts as an OR operator, meaning a row is returned if any of the conditions are true.

#### üìùExercise 1

1.  Select the "sex" and "year" columns from the data.

2.  Filter the data to show only the rows where "flipper_length_mm" is greater than 200.

3.  Filter the data to find all penguins that are either on Biscoe Island or Torgersen Island.

    ```{r}

    ```

## 4Ô∏è‚É£Pipes

üíªFilter the data to only include Adelie penguins, and then keep only the columns that start with "bill":

```{r}
select(filter(penguins, species == "Adelie"), starts_with("bill"))
```

This works, but it can get difficult to read, especially as your code grows more complex. The nested functions force you to read the code inside-out, making it less intuitive

üíªUse the pipe to do the same thing in a more streamlined way:

```{r}
penguins |> 
  filter(species == "Adelie") |> 
  select(starts_with("bill"))
```

The pipe allows us to pass the output of one function directly to the next. This approach makes your code easier to read because the operations flow left to right, top to bottom.

Keyboard shortcuts for the pipe:

-   Windows: Ctrl + Shift + M

-   Mac: Cmd + Shift + M

#### üìùExercise 2

Using the pipe, filter the data to include only female penguins with "bill_length_mm" less than or equal to 40, and then select the "species" and "bill_length_mm" columns.

```{r}
penguins |> 
  filter(sex == "female", bill_length_mm <= 40) |> 
  select(species, bill_length_mm)
```

## 5Ô∏è‚É£Create and modify columns: mutate()

In data analysis, it's common to derive new variables from existing ones. The [mutate()](https://dplyr.tidyverse.org/reference/mutate.html) function is essential for these tasks.

üíªCreate a new column called "body_mass_kg" (i.e., the "body_mass_g" column converted from grams to kilograms):

```{r}
penguins |> 
  mutate(body_mass_kg = body_mass_g / 1000)
```

By separating the new columns with a comma, we can create multiple new variables in one function call.

üíªUse [if_else()](https://dplyr.tidyverse.org/reference/if_else.html) to create a column called "large_penguin", which indicates whether the penguin's body mass is greater than 4,000 grams:

```{r}
penguins |> 
  mutate(large_penguin = if_else(body_mass_g > 4000, TRUE, FALSE))
```

üíªUse [case_when()](https://dplyr.tidyverse.org/reference/case_when.html) to categorize the penguins based on their body mass:

```{r}
penguins |> 
  mutate(size_category = case_when(
    body_mass_g < 3000 ~ "small",
    body_mass_g < 4000 ~ "medium",
    body_mass_g >= 4000 ~ "large",
    .default = "unknown"
  ))
```

if_else() is best for binary conditions where you need to choose between two outcomes. In contrast, case_when() is ideal for handling multiple conditions, allowing you to return different values based on various criteria.

üíªUse [across()](https://dplyr.tidyverse.org/reference/across.html) to efficiently round values in multiple columns simultaneously:

```{r}
penguins |> 
  mutate(across(.cols = c(bill_length_mm, bill_depth_mm), .fns = round))
```

#### üìùExercise 3

1.  Create a new column called "bill_depth_cm" that converts the "bill_depth_mm" columns from millimeters to centimeters.
2.  Create a new column called "flipper_size" that categorizes penguins as short, average, or long based on their "flipper_length_mm". *Hint: You can define short as less than 190 mm, average as between 190 and 210 mm, and long as greater than 210 mm.*

## 6Ô∏è‚É£Compute summary statistics: summarise()

We often need to summarize our data to understand key characteristics (e.g., measures of central tendency, measures of variability, frequency). The [summarise()](https://dplyr.tidyverse.org/reference/summarise.html) function lets us calculate these summary statistics efficiently.

üíªCalculate the mean body mass for all the penguins in the data.

```{r}
penguins |> 
  summarise(mean_body_mass = mean(body_mass_g, na.rm = TRUE))
```

The function creates a new data frame with a single row containing the summary statistic.

üíªCalculate the mean and standard deviation of body mass at the same time:

```{r}
penguins |> 
  summarise(mean_body_mass = mean(body_mass_g, na.rm = TRUE),
            sd_body_mass = sd(body_mass_g, na.rm = TRUE))
```

Similar to what we've seen in other functions, you can create multiple summaries in a single step by separating them with commas.

## 7Ô∏è‚É£Group by one or more variables: group_by()

## üìöResources

| Function              | Description |
|-----------------------|-------------|
| dplyr::glimpse()      |             |
| dplyr::select()       |             |
| dplyr::filter()       |             |
| dplyr::mutate()       |             |
| dplyr::summarise()    |             |
| dplyr::group_by()     |             |
| dplyr::count()        |             |
| dplyr::arrange()      |             |
| dplyr::pull()         |             |
| dplyr::slice()        |             |
| tidyr::pivot_longer() |             |
| tidyr::pivot_wider()  |             |
